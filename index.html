<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>Danny Beta QA Checker v1.1.0</title>
  <style>
    :root {
      --success:#16a34a;
      --danger:#d32f2f;
      --border:#e0e0e0;
      --text:#222;
      --muted:#6b7280;
      --good-bg:#ecfdf5;
      --bad-bg:#fef2f2;
      --good-border:#86efac;
      --bad-border:#fca5a5;
      --good-text:#166534;
      --bad-text:#991b1b;
      font-family:"SF Pro Display",Inter,system-ui,-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,Helvetica,Arial,sans-serif;
    }

    body {
      background:#fff;
      color:var(--text);
      margin:0;
      padding:40px;
      display:flex;
      flex-direction:column;
      align-items:center;
      position:relative;
    }

    h1 {
      margin:0 0 12px;
      font-size:36px !important;
      font-weight:900;
      letter-spacing:-1px;
      color:#1e40af;
      text-align:center;
      line-height:1.2;
      display:flex;
      align-items:center;
      justify-content:center;
      gap:8px;
      flex-wrap:wrap;
    }

    h1 span {
      font-size:36px !important;
      font-weight:900;
    }

    h1 .version {
      font-size:16px !important;
      font-weight:700;
      color:#64748b;
      background:#f1f5f9;
      padding:4px 10px;
      border-radius:6px;
      letter-spacing:0;
    }

    p {
      margin:0 0 18px;
      font-size:15px;
      color:#555;
      text-align:center;
      max-width:780px;
    }

    /* LEFT SIDEBAR REQUIREMENTS */
    .sidebar {
      position:absolute;
      left:40px;
      top:140px;
      width:260px;
      background:#f8fafc;
      border:1px solid #e2e8f0;
      padding:18px 20px;
      border-radius:12px;
      font-size:14px;
      line-height:1.4;
      box-shadow:0 4px 12px rgba(15,23,42,0.06);
    }

    .sidebar h3 {
      margin-top:0;
      font-size:15px;
      font-weight:700;
      color:#1e3a8a;
    }

    .sidebar ul {
      margin:8px 0 12px;
      padding-left:20px;
    }

    .sidebar li {
      margin-bottom:5px;
    }

    .sidebar .disclaimer {
      margin-top:12px;
      padding-top:10px;
      border-top:1px solid #e2e8f0;
      font-size:13px;
      font-weight:600;
      color:#b91c1c;
    }

    @media (max-width:900px) {
      .sidebar {
        position:relative;
        left:0;
        top:0;
        width:100%;
        margin-bottom:20px;
      }
    }

    .drop {
      width:100%;
      max-width:900px;
      height:140px;
      border:4px solid #3b82f6;
      border-radius:16px;
      padding:20px;
      text-align:center;
      font-weight:800;
      font-size:18px;
      cursor:pointer;
      transition:all .2s ease;
      background:#f8fafc;
      user-select:none;
      -webkit-user-select:none;
      display:flex;
      align-items:center;
      justify-content:center;
      flex-direction:column;
      gap:8px;
      color:#1e40af;
      box-shadow:0 4px 16px rgba(15,23,42,0.08);
    }
/* UNIFIED BLUE DROP ZONE (LIGHT + DARK MODE MATCH) */
.drop,
.drop.dragover {
  background: #1d4ed8 !important;     /* Solid Blue */
  border-color: #1d4ed8 !important;
  color: #ffffff !important;
  box-shadow: none !important;
}

    .drop.dragover {
      background:#dbeafe;
      border-color:#2563eb;
      box-shadow:0 0 20px rgba(59,130,246,0.3);
    }

    .drop small {
      font-weight:600;
      font-size:14px;
      color:#64748b;
    }

    .session-name {
      margin:24px 0 16px;
      font-family:monospace;
      font-size:20px !important;
      font-weight:900 !important;
      padding:16px 20px;
      border-radius:12px;
      border:2px solid #0ea5e9;
      max-width:900px;
      width:100%;
      word-break:break-all;
      text-align:center;
      box-shadow:0 4px 12px rgba(0,0,0,0.08);
      animation:fadeInUp .25s ease-out;
    }

    .session-name.good {
      background:var(--good-bg);
      border-color:var(--good-border);
      color:var(--good-text);
    }

    .session-name.bad {
      background:var(--bad-bg);
      border-color:var(--bad-border);
      color:var(--bad-text);
    }

    .illegal {
      color:#FFD700 !important;
      font-weight:bold !important;
      background:#991b1b !important;
      padding:0 3px !important;
      border-radius:3px !important;
      margin:0 !important;
      display:inline-block !important;
      line-height:1 !important;
      vertical-align:baseline !important;
    }

    .error-box {
      margin-top:8px;
      padding:10px 14px;
      background:#f4f4f4;
      border:1px solid #ddd;
      border-radius:8px;
      font-family:monospace;
      font-size:14px;
      color:#444;
      text-align:center;
      max-width:900px;
    }

    .section {
      border:1px solid var(--border);
      border-radius:10px;
      padding:20px;
      margin-top:24px;
      max-width:900px;
      width:100%;
      background:#fafafa;
      animation:fadeInUp .25s ease-out;
    }

    .section h2 {
      font-size:16px;
      font-weight:700;
      margin:0 0 12px;
      border-bottom:1px solid #ddd;
      padding-bottom:6px;
    }

    .note {
      font-size:13px;
      color:#777;
      font-style:italic;
      margin:-6px 0 10px;
    }

    .badge {
      display:inline-flex;
      align-items:center;
      gap:10px;
      padding:10px 14px;
      border-radius:8px;
      font-weight:700;
      margin-top:12px;
      font-size:14px;
    }

    .badge.ok::before {
      content:"‚úî";
      font-size:14px;
    }

    .badge.fail::before {
      content:"‚úñ";
      font-size:14px;
    }

    .ok {
      color:var(--success);
      background:#ecfdf5;
      border:1px solid #a7f3d0;
    }

    .fail {
      color:var(--danger);
      background:#ffebee;
      border:1px solid #ffcdd2;
    }

    .error-list {
      margin-top:14px;
      text-align:left;
    }

    .error-item {
      background:#fff5f5;
      border-left:4px solid var(--danger);
      padding:10px 14px;
      margin-bottom:8px;
      border-radius:4px;
      font-size:14px;
    }

    .tracks-list {
      margin-top:8px;
    }

    .track-box {
      border-radius:6px;
      padding:10px 14px;
      margin-bottom:8px;
      font-weight:600;
      display:flex;
      align-items:center;
      gap:10px;
      border:1px solid var(--good-border);
      background:var(--good-bg);
      color:var(--good-text);
      font-size:16px;
    }

    .track-box.bad {
      border-color:var(--bad-border);
      background:var(--bad-bg);
      color:var(--bad-text);
    }

    .track-num {
      background:var(--success);
      color:white;
      font-weight:700;
      padding:2px 8px;
      border-radius:4px;
      font-size:13px;
      flex-shrink:0;
    }

    .track-box.bad .track-num {
      background:#d32f2f;
    }

    .should-be {
      margin-left:44px;
      margin-top:2px;
      margin-bottom:6px;
      font-size:16px;
      color:var(--bad-text);
      font-style:normal;
      font-weight:500;
    }

    /* PARTY MODE ‚Äî ON TOP */
    #party {
      margin:40px 0 20px;
      text-align:center;
      animation:fadeIn 1s ease-in;
      width:100%;
    }

    #party .congrats {
      font-size:52px;
      font-weight:900;
      color:#16a34a;
      margin:0 0 16px;
      animation:bounce 1.2s infinite;
      letter-spacing:1px;
    }

    #party .perfect {
      font-size:30px;
      color:#ca8a04;
      font-weight:700;
      margin-bottom:12px;
    }

    #party .sparkle {
      font-size:34px;
      display:inline-block;
      animation:spin 2s linear infinite;
    }

    @keyframes fadeIn {
      from { opacity:0; }
      to { opacity:1; }
    }

    @keyframes fadeInUp {
      from {
        opacity:0;
        transform:translateY(8px);
      }
      to {
        opacity:1;
        transform:translateY(0);
      }
    }

    @keyframes bounce {
      0%,100% { transform:translateY(0); }
      50% { transform:translateY(-18px); }
    }

    @keyframes spin {
      from { transform:rotate(0deg); }
      to { transform:rotate(360deg); }
    }

    canvas {
      position:fixed;
      top:0;
      left:0;
      pointer-events:none;
      z-index:9999;
      display:none;
    }

    input[type=file] {
      display:none;
    }

    /* DARK MODE OVERRIDES */
    @media (prefers-color-scheme: dark) {
      body {
        background:#020617;
        color:#e5e7eb;
      }

      h1 {
        color:#93c5fd;
      }

      h1 .version {
        background:#0f172a;
        color:#cbd5f5;
        border:1px solid #1e293b;
      }

      p {
        color:#9ca3af;
      }

      .sidebar {
        background:#0f172a;
        border-color:#1e293b;
        box-shadow:0 8px 22px rgba(15,23,42,0.85);
      }

      .sidebar h3 {
        color:#bfdbfe;
      }

      .sidebar .disclaimer {
        border-top-color:#1e293b;
        color:#fecaca;
      }

      .drop {
        background:#020617;
        border-color:#1d4ed8;
        color:#bfdbfe;
        box-shadow:0 12px 30px rgba(15,23,42,0.9);
      }

      .drop.dragover {
        background:#0b1120;
      }

      .session-name {
        background:#020617;
        border-color:#0ea5e9;
        color:#e5e7eb;
        box-shadow:0 6px 24px rgba(15,23,42,0.9);
      }

      .session-name.good {
        background:rgba(22,163,74,0.08);
        border-color:#22c55e;
        color:#bbf7d0;
      }

      .session-name.bad {
        background:rgba(220,38,38,0.08);
        border-color:#f87171;
        color:#fecaca;
      }

      .error-box {
        background:#020617;
        border-color:#1f2937;
        color:#e5e7eb;
      }

      .section {
        background:#020617;
        border-color:#111827;
        box-shadow:0 10px 30px rgba(15,23,42,0.85);
      }

      .section h2 {
        border-bottom-color:#1f2937;
      }

      .note {
        color:#9ca3af;
      }

      .badge.ok {
        background:rgba(22,163,74,0.12);
        border-color:#22c55e;
        color:#bbf7d0;
      }

      .badge.fail {
        background:rgba(220,38,38,0.12);
        border-color:#f97373;
        color:#fecaca;
      }

      .error-item {
        background:rgba(127,29,29,0.3);
        border-left-color:#f97373;
        color:#fecaca;
      }

      .track-box {
        background:rgba(22,163,74,0.16);
        border-color:#22c55e;
        color:#bbf7d0;
      }

      .track-box.bad {
        background:rgba(127,29,29,0.35);
        border-color:#f97373;
        color:#fecaca;
      }

      .track-num {
        background:#16a34a;
      }

      .track-box.bad .track-num {
        background:#dc2626;
      }

      .should-be {
        color:#fecaca;
      }

      #party .congrats {
        color:#4ade80;
      }

      #party .perfect {
        color:#facc15;
      }

      #party .sparkle {
        color:#f9a8d4;
      }
    }
  </style>
</head>
<body>
  <div class="sidebar">
    <h3>‚ö†Ô∏èRequirements</h3>
    <ul>
      <li>Export Session Info as Text.</li><li>Include: </li>

      ‚úÖ File List<br> 

      ‚úÖ Markers<br>

     ‚úÖ  Track EDLs.<br>
  </ul>


    <div class="disclaimer">
      ‚ö†Ô∏è This is not the official Mochi QA Checker.<br>
      You still have to zip your session and upload the Dropbox URL to the Mochi QA Checker.
    </div>
  </div>

  <h1>
    Danny Beta <span>üç∫ Home Brewed QA Checker ‚úÖ</span> <span class="version">v1.1.0</span>
  </h1>
  <p>Drop your Pro Tools exported text file (.txt / .markers.txt).</p>

  <div id="droparea" class="drop">
    Drop file here
    <small>or click to choose</small>
    <input id="fileinput" type="file" accept=".txt,.markers.txt"/>
  </div>

  <div id="sessionContainer" style="width:100%;display:flex;flex-direction:column;align-items:center;">
    <div id="sessionDisplay" class="session-name" style="display:none;">
      <strong>SESSION NAME:</strong><br>
      <span id="sessionText"></span>
    </div>
    <div id="sessionError" class="error-box" style="display:none;"></div>
  </div>

  <!-- PARTY GOES HERE ‚Äî ON TOP -->
  <div id="partyContainer" style="width:100%;display:flex;flex-direction:column;align-items:center;"></div>

  <div id="output" style="margin-top:20px;width:100%;display:flex;flex-direction:column;align-items:center;"></div>

  <canvas id="confetti"></canvas>

  <script>
    (function(){
      const drop = document.getElementById('droparea');
      const fileinput = document.getElementById('fileinput');
      const output = document.getElementById('output');
      const partyContainer = document.getElementById('partyContainer');
      const sessionDisplay = document.getElementById('sessionDisplay');
      const sessionText = document.getElementById('sessionText');
      const sessionError = document.getElementById('sessionError');
      const confettiCanvas = document.getElementById('confetti');

      const esc = s => String(s || '').replace(/[&<>]/g, m => ({'&':'&amp;','<':'&lt;','>':'&gt;'}[m]));
      const normHeader = ln => String(ln || '').replace(/\s+/g,'').toUpperCase();

      const VALID_SESSION_REGEX = /^(?:[a-z]+-[a-z]+\d{4}_(t1lt2r|t2lt1r)-[a-z0-9-]+|[a-z]+\d{4,5}_[a-z0-9-]+)$/i;
      const SINGLE_SESSION_REGEX = /^([a-z]+)(\d{4,5})_([a-z0-9-]+)$/i;

      function highlightSessionName(name){
        if (VALID_SESSION_REGEX.test(name)) return esc(name);
        let html = '';
        const parts = name.split('');
        let i = 0;

        while (i < parts.length && /[a-z]/i.test(parts[i])) html += esc(parts[i++]);

        if (i < parts.length && parts[i] === '-') html += esc(parts[i++]);
        else if (i < parts.length) html += `<span class="illegal">${esc(parts[i++])}</span>`;

        while (i < parts.length && /[a-z]/i.test(parts[i])) html += esc(parts[i++]);

        let digits = 0;
        while (i < parts.length && /\d/.test(parts[i]) && digits < 4) {
          html += esc(parts[i++]);
          digits++;
        }
        while (digits < 4 && i < parts.length) {
          html += `<span class="illegal">${esc(parts[i++])}</span>`;
          digits++;
        }

        if (i < parts.length && parts[i] === '_') html += esc(parts[i++]);
        else if (i < parts.length) html += `<span class="illegal">${esc(parts[i++] || '_')}</span>`;

        const token = /_t2lt1r-/i.test(name) ? 't2lt1r' : 't1lt2r';
        for (let j = 0; j < token.length; j++) {
          if (i < parts.length && parts[i].toLowerCase() === token[j]) {
            html += esc(parts[i++]);
          } else {
            html += `<span class="illegal">${esc(parts[i++] || token[j])}</span>`;
          }
        }

        if (i < parts.length && parts[i] === '-') html += esc(parts[i++]);
        else if (i < parts.length) html += `<span class="illegal">${esc(parts[i++] || '-')}</span>`;

        while (i < parts.length) {
          const c = parts[i];
          html += /[a-z0-9-]/.test(c) ? esc(c) : `<span class="illegal">${esc(c)}</span>`;
          i++;
        }
        return html;
      }

      function getSessionName(lines){
        const first = (lines[0] || '').trim();
        const m = first.match(/^SESSION NAME:\s*(.+)$/i);
        return m ? m[1].trim() : null;
      }

      function parseSessionInfo(sessionName, tracks){
        // Dualcharacter session: {speaker1}-{speaker2}{code}_(t1lt2r|t2lt1r)-{script}
        const dualMatch = sessionName.match(/^([a-z]+)-([a-z]+)(\d{4})_(t1lt2r|t2lt1r)-([a-z0-9-]+)$/i);
        if (dualMatch) {
          return {
            type: 'dual',
            speaker1: dualMatch[1],
            speaker2: dualMatch[2],
            code: dualMatch[3],
            mode: dualMatch[4].toLowerCase(),
            script: dualMatch[5]
          };
        }

        // Singlecharacter session: {speaker1_id}{audio_file_id}_{script_name}
        // e.g. enauksjeve0002_singlecharacter003
        const singleMatch = sessionName.match(/^([a-z]+)(\d{4,5})_([a-z0-9-]+)$/i);
        if (singleMatch && /singlecharacter/i.test(singleMatch[3])) {
          const speaker1 = singleMatch[1];
          const fileId = singleMatch[2];
          const scriptRaw = singleMatch[3];

          // Normalize script: allow optional dash before 'b' tail across checks
          // singlecharacter003, singlecharacter-003, singlecharacterb003, singlecharacter-b003
          let scriptBase = scriptRaw;
          scriptBase = scriptBase.replace(/^singlecharacterb/i, 'singlecharacter-b');

          // Try to grab date from first track if available (e.g. _1107_)
          let dateFromTrack = '';
          if (Array.isArray(tracks) && tracks.length) {
            const m = tracks[0].match(/_(\d{4})_/);
            if (m) dateFromTrack = m[1];
          }

          return {
            type: 'single',
            speaker1,
            fileId,
            script: scriptBase,
            dateFromTrack
          };
        }

        return null;
      }

      function suggestCorrectedSessionName(name){
        return name
          .replace(/([a-z]+)-([a-z]+)(\d{4})-t1lt2r/i, '$1-$2$3_t1lt2r')
          .replace(/([a-z]+)-([a-z]+)(\d{4})-t2lt1r/i, '$1-$2$3_t2lt1r')
          .replace(/_t1lt2r_/i, '_t1lt2r-')
          .replace(/_t2lt1r_/i, '_t2lt1r-')
          .toLowerCase();
      }

      function parseTracks(lines){
        const found = [];
        let start = -1;
        for (let i = 0; i < lines.length; i++) {
          if (normHeader(lines[i]).includes('TRACKLISTING')) {
            start = i;
            break;
          }
        }
        if (start === -1) return [];
        for (let i = start; i < lines.length; i++) {
          if (/^TRACK NAME:/i.test(lines[i])) {
            let name = lines[i].replace(/^TRACK NAME:\s*/i, '').trim();
            name = name.replace(/\s*\([^)]*\)\s*$/, '');
            name = name.replace(/\s+/g, ' ');
            found.push(name);
          }
          if (normHeader(lines[i]).includes('MARKERSLISTING')) break;
        }
        return found;
      }

      function highlightTrackName(found, expected){
        if (found === expected) return esc(found);

        if (!expected.includes('_mixed')) {
          const wrongPart = '_t1lt2r_';
          const idx = found.indexOf(wrongPart);
          if (idx !== -1) {
            return esc(found.substring(0, idx)) +
              wrongPart.split('').map(c => `<span class="illegal">${esc(c)}</span>`).join('') +
              esc(found.substring(idx + wrongPart.length));
          }
        }

        let i = 0;
        const minLen = Math.min(found.length, expected.length);
        while (i < minLen && found[i] === expected[i]) i++;

        if (i === minLen) {
          const longer = found.length > expected.length ? found : expected;
          const shorterLen = minLen;
          return esc(longer.substring(0, shorterLen)) +
            longer.substring(shorterLen).split('').map(c => `<span class="illegal">${esc(c)}</span>`).join('');
        }

        return esc(found.substring(0, i)) +
          `<span class="illegal">${esc(found[i])}</span>` +
          esc(found.substring(i + 1));
      }

      function validateTracks(tracks, sessionInfo){
        if (!sessionInfo) return tracks.map(() => null);

        // SINGLECHARACTER: 3 tracks
        if (sessionInfo.type === 'single') {
          const date = sessionInfo.dateFromTrack || (tracks[0]?.match(/_(\d{4})_/)?.[1] || '');

          const scriptBase = sessionInfo.script;
          const scriptNoDash = scriptBase.replace(/-([bB]\d{3,4})$/, 'b$1');
          const scriptVariants = scriptNoDash === scriptBase
            ? [scriptBase]
            : [scriptBase, scriptNoDash];

          const expectedSingle = [
            `${sessionInfo.speaker1}_${date}_${scriptBase}`,
            `Talent 1_${sessionInfo.speaker1}_${date}_${scriptBase}`,
            `${sessionInfo.speaker1}_${date}_${scriptBase}_mixed`
          ];

          return tracks.map((track, i) => {
            const baseExpected = expectedSingle[i];
            if (!baseExpected) return null;

            const ok = scriptVariants.some(scr => {
              const variantExpected =
                i === 0
                  ? `${sessionInfo.speaker1}_${date}_${scr}`
                  : i === 1
                  ? `Talent 1_${sessionInfo.speaker1}_${date}_${scr}`
                  : `${sessionInfo.speaker1}_${date}_${scr}_mixed`;
              return track === variantExpected;
            });

            return ok ? null : baseExpected;
          });
        }

        // DUALCHARACTER: original 5-track logic
        const date1 = tracks[0]?.match(/_(\d{4})_/)?.[1] || '';
        const date2 = tracks[1]?.match(/_(\d{4})_/)?.[1] || '';
        const expected = [
          `${sessionInfo.speaker1}_${date1}_${sessionInfo.script}`,
          `${sessionInfo.speaker2}_${date2}_${sessionInfo.script}`,
          `${sessionInfo.mode==='t2lt1r'?'Left_Talent 2':'Left_Talent 1'}_${sessionInfo.speaker1}_${date1}_${sessionInfo.script}`,
          `${sessionInfo.mode==='t2lt1r'?'Right_Talent 1':'Right_Talent 2'}_${sessionInfo.speaker2}_${date2}_${sessionInfo.script}`,
          `${sessionInfo.speaker1}-${sessionInfo.speaker2}_${date1}_${sessionInfo.script}_mixed`
        ];
        return tracks.map((track, i) => expected[i] && track !== expected[i] ? expected[i] : null);
      }

      // NEW: Tracks section ‚Äî clean when all pass, detailed only on fail
      function renderTracksSection(tracks, expectedList){
        const hasErrors = expectedList.some(e => e !== null);
        let html = `<div class="section"><h2>Tracks</h2>`;

        // All tracks are correct ‚Üí just show PASSED badge, no list
        if (!hasErrors) {
          html += `<div class="badge ok">PASSED</div></div>`;
          return html;
        }

        // There are errors ‚Üí show FAIL badge + full visual detail
        const errorCount = expectedList.filter(e => e !== null).length;
        html += `<div class="badge fail">FAIL ‚Äî ${errorCount} issue${errorCount > 1 ? 's' : ''}</div>`;
        html += `<div class="tracks-list">`;

        tracks.forEach((t, i) => {
          const expected = expectedList[i];
          const isBad = expected !== null;
          const highlighted = highlightTrackName(t, expected || t);

          html += `
            <div class="track-box ${isBad ? 'bad' : ''}">
              <div class="track-num">${i + 1}</div>${highlighted}
            </div>`;

          if (isBad) {
            html += `<div class="should-be">Should Be: <code>${esc(expected)}</code></div>`;
          }
        });

        html += `</div></div>`;
        return html;
      }

      function parseMarkersSection(lines){
        let start = -1;
        for (let i = 0; i < lines.length; i++) {
          if (normHeader(lines[i]).includes('MARKERSLISTING')) {
            start = i;
            break;
          }
        }
        if (start === -1) return {err:"Couldn't find MARKERS LISTING section."};

        let header = -1;
        for (let j = start; j < start + 12 && j < lines.length; j++) {
          if (/NAME/i.test(lines[j])) {
            header = j;
            break;
          }
        }
        if (header === -1) header = start + 1;

        const hdr = lines[header] || '';
        const sep = hdr.includes('	') ? /	+/ : /\s{2,}/;
        const cols = hdr.split(sep).map(s => s.trim());
        const nameIdx = cols.findIndex(c => /NAME/i.test(c));
        if (nameIdx === -1) return {err:"No NAME column."};

        const trackIdx = cols.findIndex(c => /TRACK\s*NAME/i.test(c));
        const unitsIdx = cols.findIndex(c=>/\bUNITS\b/i.test(c));

        const data = [];
        for (let i = header + 1; i < lines.length; i++) {
          const raw = lines[i];
          if (!raw.trim()) break;
          const c = raw.split(sep).map(s => s.trim());
          if (c[nameIdx]) {
            data.push({
              name: c[nameIdx],
              track: trackIdx !== -1 ? (c[trackIdx] || '') : '',
              units: unitsIdx !== -1 ? (c[unitsIdx] || '') : '',
              line: i + 1
            });
          }
        }
        return {data};
      }

      function extractMarker(name){
        const m = name.match(/^([A-Za-z]+)\s*[-_ ]*\s*0*([0-9]*)/);
        if (!m) return {token:'unknown', num:null, raw:name};
        return {
          token:m[1].toLowerCase(),
          num:m[2] ? parseInt(m[2], 10) : null,
          raw:name
        };
      }

      // UPDATED markers: require at least one non-scene marker between scenes,
      // last scene can be final marker, plus all previous line/lout rules.
      // v1.1.0: Enforce that line/lout markers can only live on specific edit tracks.
      function validateMarkers(markers, sessionInfo, trackNames){
        const errors = [];
        let open = null;
        let prev = null;
        let sceneCount = 0;
        let lastScene = null; // {raw, sawNonScene:boolean}

        // Allowed track indices (1-based) where line/lout markers may appear
        let allowedTrackIndices = [];
        if (sessionInfo && sessionInfo.type === 'dual') {
          // Dualcharacter: Tracks 3 & 4 (edit tracks)
          allowedTrackIndices = [3, 4];
        } else if (sessionInfo && sessionInfo.type === 'single') {
          // Singlecharacter: Track 2 only (edit track)
          allowedTrackIndices = [2];
        }

        function getTrackIndexByName(trackName) {
          if (!trackName || !Array.isArray(trackNames)) return -1;
          const idx = trackNames.findIndex(t => t === trackName);
          return idx === -1 ? -1 : idx + 1; // 1-based
        }

        for (const m of markers) {
          const fullName = m.raw;
          const markerTrackName = m.track || '';
          const markerTrackIndex = getTrackIndexByName(markerTrackName);

          
          // Units check
          if (m.units && m.units.toLowerCase() === 'ticks') {
            if (m.token === 'scene') {
              errors.push(`Scene marker '${fullName}' created in Bars/Beats ‚Äî must be Absolute Time. Remove and create it again in Absolute Time (Not Bars).`);
            } else {
              errors.push(`UNITS = Ticks ‚Äî Change the track resolution to Samples (Not Ticks)`);
            }
          }
if (!['line','lout','scene'].includes(m.token)) {
            errors.push(`Unexpected marker '${fullName}'`);
            if (lastScene) lastScene.sawNonScene = true;
            continue;
          }

          // Enforce placement: line/lout must be on allowed tracks only
          if (['line','lout'].includes(m.token) && allowedTrackIndices.length) {
            if (markerTrackIndex === -1) {
              errors.push(`${fullName} is on unknown track '${markerTrackName}'`);
            } else if (!allowedTrackIndices.includes(markerTrackIndex)) {
              errors.push(`${fullName} placed in disallowed track '${markerTrackName}'`);
            }
          }

          if (m.token === 'scene') {
            sceneCount++;

            if (!/^scene\d+$/.test(fullName) || /[A-Z]/.test(fullName) || /\s/.test(fullName)) {
              errors.push(`Invalid scene marker '${fullName}'`);
            }

            if (lastScene && !lastScene.sawNonScene) {
              errors.push(`No markers between ${lastScene.raw} and ${fullName}`);
            }

            lastScene = { raw: fullName, sawNonScene: false };

            if (open) open.scene = true;

            continue;
          }

          // Any non-scene marker is enough to break the "gap" between scenes
          if (lastScene) lastScene.sawNonScene = true;

          if (m.token === 'line') {
            if (open) errors.push(`${open.raw} not closed`);
            open = {raw:fullName, num:m.num, line:m.line, scene:false};
          } else if (m.token === 'lout') {
            if (!open) {
              errors.push(`${fullName} without matching line`);
            } else {
              if (open.num !== m.num) errors.push(`${open.raw} to ${fullName} mismatch`);
              if (open.scene) errors.push(`scene between ${open.raw} and ${fullName}`);
              if (prev !== null && m.num !== prev + 1) errors.push(`${fullName} not sequential`);
              prev = m.num;
              open = null;
            }
          }
        }

        if (open) errors.push(`${open.raw} not closed`);
        if (sceneCount > 50) errors.push(`Too many scene markers (${sceneCount})`);
        return errors;
      }

      function parseOnlineFiles(lines){
        let start = -1;
        for (let i = 0; i < lines.length; i++) {
          if (normHeader(lines[i]).includes('ONLINEFILESINSESSION')) {
            start = i;
            break;
          }
        }
        if (start === -1) return {err:"Couldn't find ONLINE FILES section."};

        let header = -1;
        for (let j = start; j < start + 20 && j < lines.length; j++) {
          if (/file\s*name/i.test(lines[j]) && /location/i.test(lines[j])) {
            header = j;
            break;
          }
        }
        if (header === -1) return {err:"Missing FILE NAME / LOCATION columns"};

        const hdr = lines[header] || '';
        const sep = hdr.includes('	') ? /	+/ : /\s{2,}/;
        const cols = hdr.split(sep).map(s => s.trim());
        const nameIdx = cols.findIndex(c => /file\s*name/i.test(c));
        const locIdx = cols.findIndex(c => /location/i.test(c));
        if (nameIdx === -1 || locIdx === -1) return {err:"Missing columns"};

        const rows = [];
        for (let i = header + 1; i < lines.length; i++) {
          const raw = lines[i];
          if (!raw.trim()) break;
          if (/[A-Z ]+LISTING/.test(raw)) break;
          const c = raw.split(sep).map(s => s.trim());
          rows.push({file:c[nameIdx], location:c[locIdx]});
        }
        return {rows};
      }

      // *** FIXED IN v1.0.4 ***
      function isInBouncedFiles(loc){
        return /[:/]Bounced Files:?$/.test(loc || '');
      }

      // *** FIXED IN v1.0.4 ***
      function isInAudioFiles(loc){
        return /[:/]Audio Files:?$/.test(loc || '');
      }

      function normalizeScriptTail(name){
        const m = name.match(/^(.*?)(-?e\d{3,4})$/);
        if (!m) return name;
        return m[1] + m[2].replace('-', '');
      }

      function checkBouncedFiles(sessionName, rows){
        const stripExt = f => f.replace(/\.[^.]+$/, '');
        const normSession = normalizeScriptTail(sessionName);

        const parsed = rows.map(r => {
          const noExt = stripExt(r.file.trim());
          let base = noExt;
          let suffix = "";
          const m = noExt.match(/_(edit|mixed)$/);
          if (m) {
            suffix = m[1];
            base = noExt.slice(0, -m[0].length);
          }
          return {base, suffix, loc:r.location.trim()};
        });

        const foundEdit  = parsed.find(r => r.suffix === "edit"  && normalizeScriptTail(r.base) === normSession);
        const foundMixed = parsed.find(r => r.suffix === "mixed" && normalizeScriptTail(r.base) === normSession);

        const errors = [];
        if (!foundEdit)  errors.push(`Missing _edit bounce`);
        if (!foundMixed) errors.push(`Missing _mixed bounce`);
        if (foundEdit  && !isInBouncedFiles(foundEdit.loc))  errors.push(`_edit bounce not in Bounced Files`);
        if (foundMixed && !isInBouncedFiles(foundMixed.loc)) errors.push(`_mixed bounce not in Bounced Files`);

        return {pass:errors.length === 0, errors};
      }

      // Audio Files checker
      function checkAudioFiles(sessionInfo, tracks, rows){
        const stripExt = f => f.replace(/\.[^.]+$/, '');
        const errors = [];

        if (!sessionInfo || !rows || !Array.isArray(rows)) {
          return {pass:true, errors};
        }

        // Helpers (use same folder check as existing code)
        const isInAudioFiles = loc => /[:\\\/ ]Audio Files:?$/i.test(loc||'');

        // SINGLECHARACTER
        if (sessionInfo.type === 'single') {
          const date = sessionInfo.dateFromTrack || (tracks[0]?.match(/_(\d{4})_/)?.[1] || '');
          const scriptBase = sessionInfo.script;
          const scriptNoDash = scriptBase.replace(/-([bB]\d{3,4})$/, 'b$1');
          const scriptVariants = scriptNoDash === scriptBase ? [scriptBase] : [scriptBase, scriptNoDash];

          rows.forEach(r => {
            if (!isInAudioFiles(r.location)) return;
            const file = (r.file||'').trim(); if (!file) return;
            const base = stripExt(file);

            // Optional prefix for single
            let hadPrefix = false;
            let rest = base;
            if (rest.startsWith('Talent 1_')) {
              hadPrefix = true;
              rest = rest.substring('Talent 1_'.length);
            } else if (rest.startsWith('Left_Talent 1_') || rest.startsWith('Right_Talent 2_')) {
              // Invalid prefixes for SINGLE
              const expectedBase = `Talent 1_${sessionInfo.speaker1}_${date}_${scriptBase}`;
              errors.push({ file, base, expectedBase });
              return;
            }

            let anyValid = false;
            let expectedBase = `Talent 1_${sessionInfo.speaker1}_${date}_${scriptBase}`;

            for (const scr of scriptVariants) {
              const expectedNoPrefix = `${sessionInfo.speaker1}_${date}_${scr}`;
              const expectedWith     = `Talent 1_${expectedNoPrefix}`;

              if (hadPrefix) {
                if (base === expectedWith || base.startsWith(expectedWith + '_') || base.startsWith(expectedWith + '-')) { anyValid = true; break; }
              } else {
                if (rest === expectedNoPrefix || rest.startsWith(expectedNoPrefix + '_') || rest.startsWith(expectedNoPrefix + '-')) { anyValid = true; break; }
              }
            }

            if (!anyValid) {
              errors.push({ file, base, expectedBase });
            }
          });

          return {pass:errors.length===0, errors};
        }

        // DUALCHARACTER
        const date1 = tracks[0]?.match(/_(\d{4})_/)?.[1] || '';
        const date2 = tracks[1]?.match(/_(\d{4})_/)?.[1] || '';
        const scriptBase = sessionInfo.script;
        const scriptNoDash = scriptBase.replace(/-([bB]\d{2,4})$/, '$1');
        const scriptVariants = scriptNoDash === scriptBase ? [scriptBase] : [scriptBase, scriptNoDash];

        rows.forEach(r => {
          if (!isInAudioFiles(r.location)) return;
          const file = (r.file||'').trim(); if (!file) return;
          const base = stripExt(file);

          // Optional prefixes
          let prefix = null;
          let rest = base;
          const leftPrefix  = sessionInfo.mode==='t2lt1r' ? 'Left_Talent 2_' : 'Left_Talent 1_';
          if (rest.startsWith(leftPrefix)) { prefix='left';  rest = rest.substring(leftPrefix.length); }
          else if (rest.startsWith(sessionInfo.mode==='t2lt1r' ? 'Right_Talent 1_' : 'Right_Talent 2_')) { prefix='right'; rest = rest.substring((sessionInfo.mode==='t2lt1r' ? 'Right_Talent 1_' : 'Right_Talent 2_').length); }
          else if (rest.startsWith('Talent 1_')) {
            // Invalid for dual
            const expectedBase = `Left_Talent 1_${sessionInfo.speaker1}_${date1}_${scriptBase}  OR  Right_Talent 2_${sessionInfo.speaker2}_${date2}_${scriptBase}`;
            errors.push({ file, base, expectedBase });
            return;
          }

          let anyValid = false;
          let expectedBase = `Left_Talent 1_${sessionInfo.speaker1}_${date1}_${scriptBase}  OR  Right_Talent 2_${sessionInfo.speaker2}_${date2}_${scriptBase}`;

          for (const scr of scriptVariants) {
            const leftNoPrefix  = `${sessionInfo.speaker1}_${date1}_${scr}`;
            const rightNoPrefix = `${sessionInfo.speaker2}_${date2}_${scr}`;
            const leftWith      = `Left_Talent 1_${leftNoPrefix}`;
            const rightWith     = `Right_Talent 2_${rightNoPrefix}`;

            if (prefix === 'left') {
              if (base === leftWith || base.startsWith(leftWith + '_') || base.startsWith(leftWith + '-')) { anyValid = true; break; }
            } else if (prefix === 'right') {
              if (base === rightWith || base.startsWith(rightWith + '_') || base.startsWith(rightWith + '-')) { anyValid = true; break; }
            } else {
              // No prefix: must match either side using strict underscore-separated core
              if (rest === leftNoPrefix || rest.startsWith(leftNoPrefix + '_') || rest.startsWith(leftNoPrefix + '-') ||
                  rest === rightNoPrefix || rest.startsWith(rightNoPrefix + '_') || rest.startsWith(rightNoPrefix + '-')) {
                anyValid = true; break;
              }
            }
          }

          if (!anyValid) {
            errors.push({ file, base, expectedBase });
          }
        });

        return {pass:errors.length===0, errors};
      }function renderMarkersReport(errors){
        let html = `<div class="section"><h2>Markers</h2>`;
        if (!errors.length) {
          html += `<div class="badge ok">PASSED</div>`;
        } else {
          html += `<div class="badge fail">FAIL ‚Äî ${errors.length} issues</div><div class="error-list">`;
          errors.forEach(e => {
            html += `<div class="error-item">${esc(e)}</div>`;
          });
          html += `</div>`;
        }
        html += `</div>`;
        return html;
      }

      function renderAudioFilesSection(online, audioCheck){
        let html = `<div class="section"><h2>Audio Files</h2>`;

        if (online.err) {
          html += `<div class="badge fail">FAIL ‚Äî ${esc(online.err)}</div></div>`;
          return html;
        }

        const errors = audioCheck.errors || [];

        if (!errors.length) {
          html += `<div class="badge ok">PASSED</div>`;
        } else {
          html += `<div class="badge fail">FAIL ‚Äî ${errors.length} issue${errors.length > 1 ? 's' : ''}</div>`;
          html += `<div class="error-list">`;
          errors.forEach(err => {
            html += `<div class="error-item">
              <div><strong>File:</strong> ${esc(err.file)}</div>
              <div>Prefix: ${highlightTrackName(err.base, err.expectedBase)}</div>
              <div class="should-be">Should Start With: <code>${esc(err.expectedBase)}</code></div>
            </div>`;
          });
          html += `</div>`;
        }

        html += `</div>`;
        return html;
      }

      function renderBouncedSection(sessionName, online, bounced){
        let html = `<div class="section"><h2>Bounces</h2>`;

        if (online.err) {
          html += `<div class="badge fail">FAIL ‚Äî ${esc(online.err)}</div></div>`;
          return html;
        }

        if (bounced.pass) {
          html += `<div class="badge ok">PASSED</div>`;
        } else {
          html += `
  <div class="note">
    Expected:<br>
    <code>${esc(sessionName)}_edit</code><br>
    <code>${esc(sessionName)}_mixed</code>
  </div>
`;
          html += `<div class="badge fail">FAIL</div><div class="error-list">`;
          bounced.errors.forEach(e => {
            html += `<div class="error-item">${esc(e)}</div>`;
          });
          html += `</div>`;
        }

        html += `</div>`;
        return html;
      }

      function triggerParty() {
        const canvas = confettiCanvas;
        const ctx = canvas.getContext('2d');
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;

        const prefersDark = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches;

        const lightColors = ['#f87171', '#fbbf24', '#34d399', '#60a5fa', '#a78bfa', '#f472b6'];
        const darkColors  = ['#22d3ee', '#a855f7', '#facc15', '#fb7185', '#4ade80', '#38bdf8'];

        const colors = prefersDark ? darkColors : lightColors;

        const confetti = [];
        for (let i = 0; i < 120; i++) {
          confetti.push({
            x: Math.random() * canvas.width,
            y: Math.random() * canvas.height - canvas.height,
            r: Math.random() * 6 + 2,
            d: Math.random() * 8 + 3,
            color: colors[Math.floor(Math.random() * colors.length)],
            tilt: Math.random() * 10 - 10,
            tiltAngle: 0,
            tiltAngleIncrement: Math.random() * 0.07 + 0.05
          });
        }

        let animationFrame;
        function draw() {
          ctx.clearRect(0, 0, canvas.width, canvas.height);
          confetti.forEach((c, i) => {
            c.tiltAngle += c.tiltAngleIncrement;
            c.y += c.d;
            c.tilt = Math.sin(c.tiltAngle) * 15;

            if (c.y > canvas.height) {
              confetti.splice(i, 1);
            } else {
              ctx.beginPath();
              ctx.lineWidth = c.r;
              ctx.strokeStyle = c.color;
              ctx.moveTo(c.x + c.tilt + c.r / 2, c.y);
              ctx.lineTo(c.x + c.tilt, c.y + c.tilt + c.r / 2);
              ctx.stroke();
            }
          });
          if (confetti.length) {
            animationFrame = requestAnimationFrame(draw);
          } else {
            canvas.style.display = 'none';
            cancelAnimationFrame(animationFrame);
          }
        }

        canvas.style.display = 'block';
        draw();

        const party = document.createElement('div');
        party.id = 'party';
        party.innerHTML = `
          <div class="congrats">CONGRATULATIONS!!!</div>
          <div class="perfect">PERFECT SESSION!</div>
          
        `;
        partyContainer.appendChild(party);
      }

      async function handleFile(file){
        output.innerHTML = '<div>Processing‚Ä¶</div>';
        sessionDisplay.style.display = 'none';
        sessionError.style.display = 'none';
        confettiCanvas.style.display = 'none';
        partyContainer.innerHTML = '';

        const text = await file.text();
        const lines = text.split(/\r?\n/);

        const sessionName = getSessionName(lines);
        if (!sessionName) {
          output.innerHTML = `<div class="section"><div class="badge fail">No SESSION NAME found</div></div>`;
          return;
        }

        const isValid = VALID_SESSION_REGEX.test(sessionName);
        sessionDisplay.className = `session-name ${isValid ? 'good' : 'bad'}`;
        sessionText.innerHTML = highlightSessionName(sessionName);
        sessionDisplay.style.display = 'block';

        if (!isValid) {
          const corrected = suggestCorrectedSessionName(sessionName);
          sessionError.innerHTML = `<strong>INVALID SESSION FORMAT.</strong><br>Should be: <code>${esc(corrected)}</code>`;
          sessionError.style.display = 'block';
          output.innerHTML = '';
          return;
        }

        const sessionInfo = parseSessionInfo(sessionName);
        if (!sessionInfo) {
          output.innerHTML = `<div class="section"><div class="badge fail">Invalid SESSION NAME format</div></div>`;
          return;
        }

        
        // Strict Speaker ID validation (A): exactly 10 letters + 4 digits
        (function(){
          try {
            const singleRe = /^([a-z]{10})(\d{4})_/;
            const dualRe   = /^([a-z]{10})-([a-z]{10})(\d{4})_(t1lt2r|t2lt1r)-/;
            if (!(singleRe.test(sessionName) || dualRe.test(sessionName))) {
              sessionDisplay.className = "session-name bad";
              const msg = "SESSION NAME: Speaker ID must be 10 lowercase letters followed by 4 digits (e.g., enxxstnnnn0001).";
              sessionError.innerHTML = (sessionError.innerHTML ? sessionError.innerHTML + "<br>" : "") + msg;
              sessionError.style.display = "block";
              output.innerHTML = "";
              return;
            }
          } catch(e) { /* fail-safe */ }
        })();
const tracks = parseTracks(lines);
        const expectedList = validateTracks(tracks, sessionInfo);
        const tracksPass = expectedList.every(e => e === null);

        const online = parseOnlineFiles(lines);
        const audioCheck = online.err ? {pass:false, errors:[online.err]} : checkAudioFiles(sessionInfo, tracks, online.rows);
        const audioPass = !online.err && audioCheck.pass;

        const parsedMarkers = parseMarkersSection(lines);
        const markerErrors = parsedMarkers.err
          ? [parsedMarkers.err]
          : validateMarkers(
              parsedMarkers.data.map(d => ({ ...extractMarker(d.name), line: d.line, track: d.track, units: d.units })),
              sessionInfo,
              tracks
            );
        const markersPass = markerErrors.length === 0;

        const bounced = online.err ? {pass:false, errors:[online.err]} : checkBouncedFiles(sessionName, online.rows);
        const bouncedPass = !online.err && bounced.pass;

        output.innerHTML =
          renderAudioFilesSection(online, audioCheck) +
          renderTracksSection(tracks, expectedList) +
          renderMarkersReport(markerErrors) +
          renderBouncedSection(sessionName, online, bounced);

        if (tracksPass && markersPass && bouncedPass && audioPass) {
          setTimeout(triggerParty, 300);
        }
      }

      drop.addEventListener('dragover', e => {
        e.stopPropagation();
        e.preventDefault();
        drop.classList.add('dragover');
        e.dataTransfer.dropEffect = 'copy';
      });

      drop.addEventListener('dragleave', () => drop.classList.remove('dragover'));

      drop.addEventListener('drop', e => {
        e.stopPropagation();
        e.preventDefault();
        drop.classList.remove('dragover');
        if (e.dataTransfer.files[0]) handleFile(e.dataTransfer.files[0]);
      });

      drop.addEventListener('click', () => fileinput.click());

      fileinput.addEventListener('change', () => {
        if (fileinput.files[0]) handleFile(fileinput.files[0]);
      });
    })();
  </script>
</body>
</html>
